name: Build MinFFS

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-2025

    steps:
      # 1. 拉代码
      - name: Checkout repo
        uses: actions/checkout@v4

      # 2. 安装 MinGW 和 7zip（用 choco）
      - name: Install MinGW and 7zip
        run: |
          choco install -y mingw
          choco install -y 7zip

      # 3. 构建 wxWidgets 3.0.2（不再假设路径）
      - name: Build wxWidgets 3.0.2 (MinGW)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # 下载 wxWidgets 源码 ZIP （3.0.2）
          curl -L "https://sourceforge.net/projects/wxwindows/files/3.0.2/wxWidgets-3.0.2.zip/download" -o wxWidgets-3.0.2.zip

          # 使用临时目录解压，不假设里面的顶层目录叫什么
          $wxTmp = "C:\wx-src"
          if (Test-Path $wxTmp) {
            Remove-Item $wxTmp -Recurse -Force
          }
          New-Item -ItemType Directory -Path $wxTmp | Out-Null

          Expand-Archive -Path "wxWidgets-3.0.2.zip" -DestinationPath $wxTmp -Force

          # 递归查找 makefile.gcc，找到 MSW 构建目录
          $makefile = Get-ChildItem -Path $wxTmp -Recurse -Filter "makefile.gcc" | Select-Object -First 1
          if (-not $makefile) {
            throw "makefile.gcc not found under $wxTmp (wxWidgets sources not as expected)"
          }

          $mswDir = Split-Path $makefile.FullName -Parent          # ...\build\msw
          # wx 根目录 = mswDir 的上两级
          $buildDir = Split-Path $mswDir -Parent                   # ...\build
          $wxRoot   = Split-Path $buildDir -Parent                 # wx 根

          if (-not (Test-Path "$wxRoot\include") -or -not (Test-Path "$wxRoot\build")) {
            throw "Wx root '$wxRoot' does not look like a wxWidgets source tree."
          }

          # 把 wx 根目录导出到 GITHUB_ENV，后续步骤可以用 $env:WX_ROOT
          "WX_ROOT=$wxRoot" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          # 配好环境变量（让 make 能找到 MinGW，wxWidgets 用到 WXWIN）
          $env:WXWIN = $wxRoot
          $env:PATH  = "C:\ProgramData\mingw64\mingw64\bin;$env:PATH"

          # 进入 MSW 构建目录
          Set-Location $mswDir

          # 按 README 用 MinGW 构建：先 release 再 debug，生成 mswu / mswud 两套库
          mingw32-make -f makefile.gcc BUILD=release SHARED=0 CXXFLAGS="-std=gnu++14"
          mingw32-make -f makefile.gcc BUILD=debug   SHARED=0 CXXFLAGS="-std=gnu++14"

          # 用完可以删临时解压目录（不删其实也无所谓）
          Remove-Item $wxTmp -Recurse -Force

      # 4. 构建 Boost 1.58.0，安装到 C:\Boost-w64
      - name: Build Boost 1.58.0 (MinGW)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # 准备临时目录
          $boostTmpRoot = "C:\build-boost"
          if (Test-Path $boostTmpRoot) {
            Remove-Item $boostTmpRoot -Recurse -Force
          }
          New-Item -ItemType Directory -Path $boostTmpRoot | Out-Null

          Set-Location $boostTmpRoot

          # 下载 Boost 1.58.0 源码 ZIP
          curl -L "https://sourceforge.net/projects/boost/files/boost/1.58.0/boost_1_58_0.zip/download" -o boost_1_58_0.zip

          # 解压到临时目录，不假设顶层文件夹名
          Expand-Archive -Path "boost_1_58_0.zip" -DestinationPath $boostTmpRoot -Force

          # 找到真正的 boost 根目录（包含 bootstrap.bat 的那个）
          $boostRootDir = Get-ChildItem -Path $boostTmpRoot -Recurse -Filter "bootstrap.bat" | Select-Object -First 1
          if (-not $boostRootDir) {
            throw "bootstrap.bat not found under $boostTmpRoot (Boost sources not as expected)"
          }
          $boostRoot = Split-Path $boostRootDir.FullName -Parent
          Set-Location $boostRoot

          # 确保 MinGW 在 PATH 里，让 bootstrap.bat / b2 能找到 g++
          $env:PATH = "C:\ProgramData\mingw64\mingw64\bin;$env:PATH"

          # 走 README 的流程：bootstrap + b2 install
          .\bootstrap.bat mingw

          .\b2 toolset=gcc `
             variant=release `
             threading=multi `
             --prefix=C:\Boost-w64 `
             --without-mpi `
             --without-python install

      # 5. 用 MinGW 平台的 Makefile 编译 MinFFS
      - name: Build MinFFS (MinGW)
        working-directory: src+builder/FreeFileSync/Platforms/MinGW
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          if (-not $env:WX_ROOT) {
            throw "WX_ROOT is not set from previous step."
          }

          # 这里通过命令行覆写 Makefile 里的几个根路径，
          # 用 CI 里刚装好的这些路径
          mingw32-make -f Makefile-cmdexe.mk `
            MINGW_ROOT=C:/ProgramData/mingw64/mingw64 `
            WXWGT_ROOT=$env:WX_ROOT `
            BOOST_ROOT=C:/Boost-w64 `
            BOOST_VER=1_58 `
            BOOST_MINGW=mgw52 `
            all

      # 6. 上传生成的 MinFFS.exe
      - name: Upload MinFFS.exe
        uses: actions/upload-artifact@v4
        with:
          name: MinFFS
          path: src+builder/FreeFileSync/Platforms/MinGW/MinFFS.exe
          if-no-files-found: error
